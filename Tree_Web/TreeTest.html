<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Three.js ì…ë¬¸</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    /* ... ê¸°ì¡´ ìŠ¤íƒ€ì¼ ... */
    
    /* [ìƒˆ ê¸°ëŠ¥] ì•ŒëŒ UI ë””ìì¸ */
   /* [ìˆ˜ì •] ì•ŒëŒ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
    #alarm-container {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 250px;
        /* ì•ŒëŒì´ ë§ì•„ì§€ë©´ ìŠ¤í¬ë¡¤ ìƒê¸°ê²Œ ì„¤ì • */
        max-height: 400px; 
        overflow-y: auto;
        
        /* ë§ˆìš°ìŠ¤ í´ë¦­ í†µê³¼ X (ì‚­ì œ ë²„íŠ¼ ëˆŒëŸ¬ì•¼ í•˜ë¯€ë¡œ) */
        pointer-events: auto; 
        
        display: flex;
        flex-direction: column;
        gap: 10px; /* ì•ŒëŒ ì‚¬ì´ ê°„ê²© */
        z-index: 1000; /* ë‹¤ë¥¸ ìš”ì†Œë³´ë‹¤ ìœ„ì— */
    }

    /* [ìƒˆ ê¸°ëŠ¥] ê°œë³„ ì•ŒëŒ ì•„ì´í…œ ìŠ¤íƒ€ì¼ */
    .alarm-item {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 12px 20px;
        border-radius: 15px;
        font-family: 'Pretendard', sans-serif;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        cursor: pointer; /* í´ë¦­ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì†ê°€ë½ í‘œì‹œ */
        transition: all 0.2s ease;
        
        display: flex;
        justify-content: space-between; /* ì‹œê°„ê³¼ ì‚­ì œ ì•„ì´ì½˜ ì–‘ë ë°°ì¹˜ */
        align-items: center;
    }

    /* ë§ˆìš°ìŠ¤ ì˜¬ë ¸ì„ ë•Œ íš¨ê³¼ */
    .alarm-item:hover {
        background-color: rgba(255, 80, 80, 0.9); /* ë¶‰ì€ìƒ‰ìœ¼ë¡œ ë³€í•¨ */
        transform: scale(1.03); /* ì‚´ì§ ì»¤ì§ */
    }

    /* ì‚­ì œë  ë•Œ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ */
    .alarm-item.removing {
        opacity: 0;
        transform: translateX(50px);
    }
    
    /* ì‹œê°„ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
    .alarm-time {
        font-size: 18px;
        font-weight: bold;
    }
    
    /* ì‚­ì œ ì•ˆë‚´ í…ìŠ¤íŠ¸ (ì‘ê²Œ) */
    .delete-hint {
        font-size: 12px;
        opacity: 0.7;
        margin-left: 10px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="alarm-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.141.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    const ws = new WebSocket("ws://192.168.0.3:3001"); // ë§¥ IPë¡œ ë„£ê¸°
    ws.onopen = () => {
      console.log("WebSocket Connected to server");
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "command") {
          console.log("ì„œë²„ì—ì„œ ëª…ë ¹ ìˆ˜ì‹ :", data.command);
          parseCommand(data.command);    // ì½˜ì†” ëª…ë ¹ì–´ íŒŒì„œ í•¨ìˆ˜ í˜¸ì¶œ
        }
      } catch (e) {
        console.error("ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜", e);
      }
    };
    // --- ëª¨ë“ˆ ì„í¬íŠ¸ ---
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // --- ì „ì—­ ë³€ìˆ˜ ---
    let model_car;
    const clock = new THREE.Clock();

    // [ìƒˆ ê¸°ëŠ¥] ë¶€ë“œëŸ¬ìš´ ì´ë™ì„ ìœ„í•œ ëª©í‘œ ì§€ì  ë³€ìˆ˜
    let targetPosition = null;
    let targetRotation = 0; // Yì¶• íšŒì „ê°’ (ë¼ë””ì•ˆ)
    // -------------------------------------------
    // í‚¤ë³´ë“œ ìƒíƒœ
    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
    };
    
    // ë§ˆìš°ìŠ¤ íœ  ì¤Œ ì„¤ì •
    const minZoomDistance = 2.0;
    const maxZoomDistance = 15.0;
    const zoomSpeed = 0.005;
    
    // --- ë°© ì¢Œí‘œ ë° ìë™ ì´ë™ ë³€ìˆ˜ ---

    const car_y = 0.2;
    const roomData = {
      living_room: new THREE.Vector3(0.0, car_y, -0.3),
      inner_room: new THREE.Vector3(0.25, car_y, 1.2),
      kitchen: new THREE.Vector3(-0.9, car_y, 0.0)
    };

    // ì¤‘ê°„ ê²½ë¡œì  (Waypoint) ì •ì˜
    const INNER_ROOM_DOORWAY = new THREE.Vector3(
      0.2,
      car_y,
      0.4
    );
    const KITCHEN_DOORWAY = new THREE.Vector3(
      -0.75,
      car_y,
      -0.15
    );
    
    // ì´ë™ ê²½ë¡œ(Path) ë°ì´í„°
    const pathData = {
      living_room_to_inner_room: [ INNER_ROOM_DOORWAY, roomData.inner_room ],
      inner_room_to_living_room: [ INNER_ROOM_DOORWAY, roomData.living_room ],
      living_room_to_kitchen: [ KITCHEN_DOORWAY, roomData.kitchen ],
      kitchen_to_living_room: [ KITCHEN_DOORWAY, roomData.living_room ],
      inner_room_to_kitchen: [ INNER_ROOM_DOORWAY, roomData.living_room, KITCHEN_DOORWAY, roomData.kitchen ],
      kitchen_to_inner_room: [ KITCHEN_DOORWAY, roomData.living_room, INNER_ROOM_DOORWAY, roomData.inner_room ]
    };

    // --- í•¸ë“œí° ìŠ¤í° í¬ì¸íŠ¸ ---
    const effectSpawnPoints = [
      new THREE.Vector3(0.7, car_y, 1.1),   
      new THREE.Vector3(0.65, car_y, -0.4),  
      new THREE.Vector3(-1.0,car_y, 0.25),  
      new THREE.Vector3(-1.0, car_y, -1.1),  
    ];
// --------------------------------------------------

    // ìë™ ì´ë™ ìƒíƒœ ë³€ìˆ˜
    let currentRoom = "living_room"; // ìë™ì°¨ì˜ í˜„ì¬ ë°© (ì‹œì‘ ìœ„ì¹˜)
    let movementQueue = []; // ë”°ë¼ê°ˆ ê²½ë¡œì  ë°°ì—´
    let currentTarget = null; // í˜„ì¬ ì´ë™ ì¤‘ì¸ ëª©í‘œ ê²½ë¡œì 
    
    // --- 3. Scene ìƒì„± ---
    let scene = new THREE.Scene();
    scene.background = new THREE.Color("skyblue");

    // --- 4. Camera ìƒì„± ---
    let camera = new THREE.PerspectiveCamera(
      45, // fov
      window.innerWidth / window.innerHeight, // aspect
      0.1, // near
      1000 // far
    );

    // --- [ìƒˆ ê¸°ëŠ¥] ì˜¤ë””ì˜¤ ë¦¬ìŠ¤ë„ˆ & ì´í™íŠ¸ ê´€ë¦¬ ---
    // 1. ì¹´ë©”ë¼ì— ê·€(AudioListener)ë¥¼ ë‹¬ì•„ì¤ë‹ˆë‹¤.
    const listener = new THREE.AudioListener();
    camera.add(listener);

    // 2. ì‚¬ìš´ë“œì™€ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•  ë¡œë” ì¤€ë¹„
    const audioLoader = new THREE.AudioLoader();
    const textureLoader = new THREE.TextureLoader();

    // 3. í™œì„±í™”ëœ ì´í™íŠ¸ë“¤ì„ ì €ì¥í•  ë°°ì—´ (ì• ë‹ˆë©”ì´ì…˜ ìš©)
    const activeEffects = []; 

    // 4. ë¦¬ì†ŒìŠ¤ ë¯¸ë¦¬ ë¡œë“œ (ê²½ë¡œëŠ” ì‹¤ì œ íŒŒì¼ëª…ì— ë§ê²Œ ìˆ˜ì •í•˜ì„¸ìš”)
    let effectSoundBuffer = null;
    let alarmSoundBuffer = null;
    let effectTexture = null;

    //ì•ŒëŒ ê´€ë¦¬ìš© ë¦¬ìŠ¤íŠ¸
    const alarmList = [];

    audioLoader.load('models/bip.mp3', function(buffer) {
        effectSoundBuffer = buffer;
    });
    audioLoader.load('models/Alarm.mp3', function(buffer) {
        alarmSoundBuffer = buffer;
    });
    textureLoader.load('models/note_img.png', function(texture) {
        effectTexture = texture;
    });
    // ------------------------------------------
    camera.position.set(0, 5, 2); // Yì¶•ì„ ë†’ì—¬ ìœ„ì—ì„œ ë³´ë„ë¡ ì„¤ì •
    // === [í•˜ì´ë¼ì´íŠ¸(í€ì¹˜ ì¤Œ)ìš© ì „ì—­ ë³€ìˆ˜ ì¶”ê°€] ===
    let isHighlighting = false;
    let highlightStartTime = 0;
    const highlightTotalDuration = 0.6; // ì „ì²´ ì¤Œ ì¸+ì•„ì›ƒ ì‹œê°„(ì´ˆ)

    const camFrom = new THREE.Vector3(); // ì›ë˜ ì¹´ë©”ë¼ ìœ„ì¹˜
    const camTo   = new THREE.Vector3(); // RCì¹´ ê°€ê¹Œì´ì—ì„œ ë³¼ ì¹´ë©”ë¼ ìœ„ì¹˜
    const highlightOffset = new THREE.Vector3(0.4, 0.6, 0.8); // ì°¨ ê¸°ì¤€ìœ¼ë¡œ ì‚´ì§ ìœ„/ì• ëŒ€ê°ì„ ì—ì„œ ë³´ëŠ” ìœ„ì¹˜ ì˜¤í”„ì…‹

    // --- 5. Light ì¶”ê°€ ---
    let PLight = new THREE.PointLight(0xffffff, 1.0);
    let ALight = new THREE.AmbientLight(0xffffff, 0.5);
    PLight.position.set(10, 10, 10);
    scene.add(PLight, ALight);

    // --- [ìƒˆ ê¸°ëŠ¥] ë°© ì´ë¦„í‘œ ë§Œë“¤ê¸° ---
    function createRoomLabel(name, position) {
        const div = document.createElement('div');
        div.className = 'label';
        // HTMLë¡œ ìŠ¤íƒ€ì¼ë§ (ë°˜íˆ¬ëª… ê²€ì€ ë°•ìŠ¤ì— í° ê¸€ì”¨)
        div.textContent = name;
        div.style.marginTop = '-1em'; // ë¼ë²¨ ìœ„ì¹˜ ë¯¸ì„¸ ì¡°ì •
        div.style.color = 'white';
        div.style.background = 'rgba(200, 0, 0, 0.6)';
        div.style.padding = '6px 14px';
        div.style.borderRadius = '12px';
        div.style.fontFamily = 'Pretendard, sans-serif';
        div.style.fontSize = '20px';
        div.style.fontWeight = 'bold';
        div.style.border = '1px solid rgba(255, 255, 255, 0.3)';

        const label = new CSS2DObject(div);
        label.position.copy(position);
        label.position.y += 0.0; // ë°”ë‹¥ë³´ë‹¤ 1.5m ìœ„ì— ë‘¥ë‘¥ ë„ìš°ê¸°
        scene.add(label);
    }

    // roomDataì— ìˆëŠ” ëª¨ë“  ë°©ì— ë¼ë²¨ ë¶™ì´ê¸°
    // (í•œê¸€ ì´ë¦„ìœ¼ë¡œ ë³€í™˜í•´ì„œ í‘œì‹œ)
    const roomNamesKr = {
        living_room: "ê±°ì‹¤",
        inner_room: "ì•ˆë°©",
        kitchen: "ì£¼ë°©"
    };

    for (const [key, pos] of Object.entries(roomData)) {
        const krName = roomNamesKr[key] || key;
        createRoomLabel(krName, pos);
    }
    // ----------------------------------------

    // --- 6. Renderer ìƒì„± ---
    let renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector("#canvas"),
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;

    // --- [ìƒˆ ê¸°ëŠ¥] ë¼ë²¨ ë Œë”ëŸ¬ ì„¤ì • (ì¶”ê°€) ---
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    
    // ìŠ¤íƒ€ì¼ ì„¤ì • (ìº”ë²„ìŠ¤ ìœ„ì— ê²¹ì³ì„œ í‘œì‹œ)
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    
    // [ì¤‘ìš”] ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ê°€ ë¼ë²¨ì„ í†µê³¼í•´ì„œ ìº”ë²„ìŠ¤ì— ë‹¿ê²Œ í•¨
    // (ì´ê²Œ ì—†ìœ¼ë©´ ë§ˆìš°ìŠ¤ íœ  ì¤Œì´ë‚˜ ì•ŒëŒ í´ë¦­ì´ ì•ˆ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤)
    labelRenderer.domElement.style.pointerEvents = 'none'; 
    
    document.body.appendChild(labelRenderer.domElement);
    // ----------------------------------------

    // --- 7. 3D ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ---
    let loader = new GLTFLoader();
    
    const modelPath_House = "models/house_ex4.glb";
    const modelPath_Car = "models/car_bot.glb"; // (ê²½ë¡œ ë’¤ ê³µë°± ì œê±°ë¨)

    loader.load(modelPath_House, function (gltf) {
      const model = gltf.scene;
      model.scale.set(2, 2, 2);
      scene.add(model);
    });
    
    loader.load(modelPath_Car, function (gltf) {
      model_car = gltf.scene;
      model_car.scale.set(0.1, 0.1, 0.1);
      model_car.position.set(0.0,car_y,-0.3);
      scene.add(model_car);
      // [ìƒˆ ê¸°ëŠ¥] ë¡œë“œ ì§í›„, ëª©í‘œ ì§€ì ì„ í˜„ì¬ ìœ„ì¹˜ë¡œ ì´ˆê¸°í™”
      targetPosition = model_car.position.clone();
      targetRotation = model_car.rotation.y;
      // -------------------------------------------------
    });

    // --- 8. ìë™ ì´ë™ í•¨ìˆ˜ ---
    /**
     * ì§€ì •ëœ ë°©ìœ¼ë¡œ ìë™ ì´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤.
     */
    function moveToRoom(toRoomName) {
      if (toRoomName === currentRoom || currentTarget) {
        return; // ì´ë¯¸ ì´ë™ ì¤‘ì´ê±°ë‚˜ ê°™ì€ ë°©ì´ë©´ ë¬´ì‹œ
      }
      
      const pathKey = `${currentRoom}_to_${toRoomName}`;
      const path = pathData[pathKey];

      if (!path) {
        console.error(`Error: '${pathKey}' ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }
      
      console.log(`ìë™ ì´ë™: ${pathKey}`);
      movementQueue = [...path]; // ê²½ë¡œ ë³µì‚¬

      if (movementQueue.length > 0) {
        // ìˆ˜ë™ ì¡°ì‘ í›„ ìœ„ì¹˜ ë³´ì •ì„ ìœ„í•´ ì‹œì‘ì (í˜„ì¬ ë°©)ìœ¼ë¡œ ì°¨ë¥¼ ìŠ¤ëƒ…
        //model_car.position.copy(roomData[currentRoom]);
        currentTarget = movementQueue.shift(); // ì²« ë²ˆì§¸ ê²½ë¡œì  ì„¤ì •
      }
      
      currentRoom = toRoomName; // í˜„ì¬ ë°© ìƒíƒœ ê°±ì‹ 
      // ë°© ì´ë™ ëª…ë ¹ ë“¤ì–´ì˜¤ë©´ ì¹´ë©”ë¼ í•˜ì´ë¼ì´íŠ¸
      //triggerHighlight();
    }
        // --- maum_0 ë°©í–¥ ëª…ë ¹ìš© ìˆ˜ë™ ì´ë™ í•¨ìˆ˜ ---
    let MoveSpeed = 2;
    let MoveStep = 1;
    let commandMoveStep = MoveStep * 0.03;  // í•œ ë²ˆì— ì´ë™ ê±°ë¦¬
    let commandMoveSpeed = MoveSpeed *0.1; // MoveSpeed*ì†ë„ë³´ì •ê³„ìˆ˜
    let commandRotateStep = Math.PI / 12;  // í•œ ë²ˆì— íšŒì „ ê°ë„

   function moveRobotInDirection(direction) {
      if (!model_car || !targetPosition) { // targetPosition ì²´í¬ ì¶”ê°€
        console.error("model_carê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
      }

      // ìˆ˜ë™ ì œì–´ ì‹œ ìë™ ê²½ë¡œ ëŠê¸°
      currentTarget = null; 
      movementQueue = [];

      // ì´ë™ ê±°ë¦¬ ê³„ì‚° (ìŠ¤ì¼€ì¼ ë³´ì • í¬í•¨)
      const step = commandMoveStep / model_car.scale.x;

      switch (direction) {
        case 1: // ì•ìœ¼ë¡œ
          // í˜„ì¬ ë¡œë´‡ì´ ë°”ë¼ë³´ëŠ” ë°©í–¥(local Z)ì„ ê³„ì‚°í•´ì„œ ëª©í‘œ ìœ„ì¹˜ì— ë”í•¨
          const forward = new THREE.Vector3(0, 0, 1);
          forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetRotation);
          targetPosition.add(forward.multiplyScalar(step));
          
          console.log("ì•ìœ¼ë¡œ ì´ë™ (ëª©í‘œ ì„¤ì •)");
          break;

        case 2: // ë’¤ë¡œ
          const backward = new THREE.Vector3(0, 0, 1);
          backward.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetRotation);
          targetPosition.add(backward.multiplyScalar(-step));
          
          console.log("ë’¤ë¡œ ì´ë™ (ëª©í‘œ ì„¤ì •)");
          break;

        case 3: // ì™¼ìª½ íšŒì „
          targetRotation += commandRotateStep;
          console.log("ì™¼ìª½ íšŒì „ (ëª©í‘œ ì„¤ì •)");
          break;

        case 4: // ì˜¤ë¥¸ìª½ íšŒì „
          targetRotation -= commandRotateStep;
          console.log("ì˜¤ë¥¸ìª½ íšŒì „ (ëª©í‘œ ì„¤ì •)");
          break;

        default:
          console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” direction:", direction);
      }
      //triggerHighlight();
    }
    // --- [ìƒˆ ê¸°ëŠ¥] ëœë¤ ì´í™íŠ¸ ìƒì„± í•¨ìˆ˜ ---
   function triggerRandomEffect() {
        if (!effectSoundBuffer || !effectTexture) {
            console.log("ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...");
            return; 
        }

        // [ìˆ˜ì •ëœ ë¶€ë¶„] ------------------------------------------
        // 1. ìŠ¤í° í¬ì¸íŠ¸ ë°°ì—´ì˜ ê¸¸ì´ ë‚´ì—ì„œ ëœë¤í•œ ì¸ë±ìŠ¤(0 ~ 4)ë¥¼ ë½‘ìŠµë‹ˆë‹¤.
        const randomIndex = Math.floor(Math.random() * effectSpawnPoints.length);
        
        // 2. í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ì¢Œí‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        const selectedPoint = effectSpawnPoints[randomIndex];
        
        console.log(`ğŸ’¥ ì´í™íŠ¸ ë°œìƒ! ì¸ë±ìŠ¤: ${randomIndex}, ì¢Œí‘œ: ${selectedPoint.x}, ${selectedPoint.z}`);
        // ------------------------------------------------------

        // 3. ì‹œê° íš¨ê³¼ (Sprite) ìƒì„±
        const material = new THREE.SpriteMaterial({ 
            map: effectTexture, 
            color: 0xffffff, 
            transparent: true,
            blending: THREE.AdditiveBlending 
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.5, 0.5, 0.5); 
        
        // [ì¤‘ìš”] ì„ íƒëœ ì¢Œí‘œë¡œ ìœ„ì¹˜ ì„¤ì •
        sprite.position.copy(selectedPoint); 
        sprite.position.y = 1.0;
        
        scene.add(sprite);

        // 4. 3D ì‚¬ìš´ë“œ ìƒì„±
        const sound = new THREE.PositionalAudio(listener);
        sound.setBuffer(effectSoundBuffer);
        sound.setRefDistance(1); 
        sound.setVolume(1.0);    
        
        sprite.add(sound);
        sound.play();

        // 5. ê´€ë¦¬ ë°°ì—´ì— ì¶”ê°€
        activeEffects.push({ mesh: sprite, life: 1.0, opacity: 1.0 , tpe: 'sound'});
    }
    // --- [ìƒˆ ê¸°ëŠ¥] ë¡œë´‡ ìœ„ì¹˜ì—ì„œ ì•ŒëŒ ìš¸ë¦¬ê¸° ---
    function triggerAlarm() {
        // 1. ì¤€ë¹„ë¬¼ í™•ì¸ (ë¡œë´‡, ì‚¬ìš´ë“œ)
        if (!model_car || !alarmSoundBuffer) {
            console.log("ë¡œë´‡ì´ ì—†ê±°ë‚˜ ì•ŒëŒ ì‚¬ìš´ë“œê°€ ë¡œë”©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return; 
        }
        // 2. ì‹œê° íš¨ê³¼: ë¶‰ì€ìƒ‰ ë§ (RingGeometry)
        const geometry = new THREE.RingGeometry(0.15, 0.25, 32);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000, // ìƒˆë¹¨ê°„ìƒ‰
            transparent: true, 
            opacity: 1.0, 
            side: THREE.DoubleSide 
        });
        const shockwave = new THREE.Mesh(geometry, material);
        
        // 3. ìœ„ì¹˜ ì„¤ì • (ì¤‘ìš”: ë¡œë´‡ì˜ í˜„ì¬ ìœ„ì¹˜ ë³µì‚¬)
        shockwave.position.copy(model_car.position);
        
        // ë°”ë‹¥ì— ëˆ•íˆê³  ë†’ì´ ë¯¸ì„¸ ì¡°ì •
        shockwave.rotation.x = -Math.PI / 2; 
        shockwave.position.y = 0.5; 
        scene.add(shockwave);

        // 4. ì²­ê° íš¨ê³¼: 3D ì‚¬ìš´ë“œ
        const sound = new THREE.PositionalAudio(listener);
        sound.setBuffer(alarmSoundBuffer);
        sound.setRefDistance(1); 
        sound.setVolume(1.5); // ì•ŒëŒì´ë‹ˆê¹Œ ì†Œë¦¬ë¥¼ ì¢€ ë” í¬ê²Œ
        
        // ë§ì— ì†Œë¦¬ë¥¼ ë¶™ì—¬ì„œ ì¬ìƒ
        shockwave.add(sound);
        sound.play();

        // 5. ê´€ë¦¬ ë°°ì—´ì— ì¶”ê°€ (type: 'alarm'ìœ¼ë¡œ êµ¬ë¶„)
        activeEffects.push({ mesh: shockwave, life: 2.0, type: 'alarm' });
    }
    function triggerVibrationEffect() {
        // ëœë¤ ìœ„ì¹˜ ì„ íƒ
        const randomIndex = Math.floor(Math.random() * effectSpawnPoints.length);
        const selectedPoint = effectSpawnPoints[randomIndex];
        console.log(`ğŸ“³ ì§„ë™ ë°œìƒ! ì¸ë±ìŠ¤: ${randomIndex}`);

        // ë§ ìƒì„±
        const geometry = new THREE.RingGeometry(0.1, 0.15, 32);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xffff00, transparent: true, opacity: 1.0, side: THREE.DoubleSide 
        });
        const shockwave = new THREE.Mesh(geometry, material);
        
        shockwave.position.copy(selectedPoint);
        shockwave.rotation.x = -Math.PI / 2; // ë°”ë‹¥ì— ëˆ•í˜
        shockwave.position.y = 1.0; // ë°”ë‹¥ ì‚´ì§ ìœ„
        scene.add(shockwave);

        // ë°°ì—´ì— ì¶”ê°€ (type: 'vibration'ìœ¼ë¡œ êµ¬ë¶„)
        activeEffects.push({ mesh: shockwave, life: 1.0, type: 'vibration' });
    }

    // === [í•˜ì´ë¼ì´íŠ¸ íŠ¸ë¦¬ê±° í•¨ìˆ˜ ì¶”ê°€] ===
    function triggerHighlight() {
      if (!model_car) return;

      isHighlighting = true;
      highlightStartTime = clock.getElapsedTime();

      // í˜„ì¬ ì¹´ë©”ë¼ ìœ„ì¹˜ ì €ì¥
      camFrom.copy(camera.position);

      // RCì¹´ ê¸°ì¤€ìœ¼ë¡œ ì‚´ì§ ìœ„/ì•ì—ì„œ ë³´ëŠ” ìœ„ì¹˜ ê³„ì‚°
      camTo.copy(model_car.position).add(highlightOffset);
    }
/**
 * í•œêµ­ì–´ ì‹œê°„ í‘œí˜„ì„ íŒŒì‹±í•´ì„œ { hour, minute, isRelative, dayOffset }ë¡œ ë³€í™˜
 *
 * ì§€ì› ì˜ˆì‹œ:
 *  - ì ˆëŒ€ ì‹œê°„:
 *    "ì˜¤ì „ 5ì‹œ", "ì˜¤í›„ ì„¸ì‹œ ì´ì‹­ë¶„", "ì—¬ëŸì‹œ", "ì´ì‹­ì‹œì‚¼ì‹­ì˜¤ë¶„",
 *    "ì˜¤ëŠ˜ ì €ë… ì—¬ëŸì‹œ", "ë‚´ì¼ ìƒˆë²½ ë‘ì‹œ ë°˜", "ëª¨ë ˆ ì ì‹¬"
 *
 *  - ìƒëŒ€ ì‹œê°„:
 *    "1ì‹œê°„ ë’¤", "ë‘ì‹œê°„ ì‚¼ì‹­ë¶„í›„", "ì´ì‹­ë¶„ë’¤",
 *    "3ì¼ í›„ ì˜¤ì „ 5ì‹œ", "ì´í‹€ ë’¤ ì €ë… ì—¬ì„¯ì‹œ",
 *    "í•˜ë£¨ ë’¤ ì ì‹¬"
 */
function convertKoreanToTime(text) {
  // 0. ê³µë°± ì œê±°
  text = text.replace(/\s+/g, '');

  let hour = 0;
  let minute = 0;
  let isRelative = false; // "ë’¤", "í›„" ì—¬ë¶€
  let dayOffset = 0;      // ì˜¤ëŠ˜ ê¸°ì¤€ ë‚ ì§œ ì˜¤í”„ì…‹ (ì˜¤ëŠ˜=0, ë‚´ì¼=1, ëª¨ë ˆ=2, ì–´ì œ=-1 ...)

  // 1. ìƒëŒ€ ì‹œê°„ ì—¬ë¶€
  if (text.includes('ë’¤') || text.includes('í›„')) {
    isRelative = true;
  }

  // 2. ë‚ ì§œ ë‹¨ì–´ ì²˜ë¦¬ (ì˜¤ëŠ˜/ë‚´ì¼/ëª¨ë ˆ/ê¸€í”¼/ì–´ì œ/ê·¸ì œ)
  if (text.includes('ì˜¤ëŠ˜')) {
    dayOffset += 0;
  } else if (text.includes('ë‚´ì¼')) {
    dayOffset += 1;
  } else if (text.includes('ëª¨ë ˆ')) {
    dayOffset += 2;
  } else if (text.includes('ê¸€í”¼')) {
    dayOffset += 3;
  } else if (text.includes('ì–´ì œ')) {
    dayOffset -= 1;
  } else if (text.includes('ê·¸ì œ')) {
    dayOffset -= 2;
  }

  // 3. ì˜¤ì „/ì˜¤í›„/ì‹œê°„ëŒ€ í‘œí˜„
  const isPM = /ì˜¤í›„|ì €ë…|ë°¤/.test(text);
  const isAM = /ì˜¤ì „|ì•„ì¹¨|ìƒˆë²½/.test(text);

  const KOREAN_DIGITS = {
    'ê³µ': 0, 'ì˜': 0,
    'ì¼': 1, 'ì´': 2, 'ì‚¼': 3, 'ì‚¬': 4, 'ì˜¤': 5,
    'ìœ¡': 6, 'ì¹ ': 7, 'íŒ”': 8, 'êµ¬': 9
  };

  // ì‹œê°„ì—ì„œ ì“°ëŠ” ê³ ìœ ì–´ ìˆ«ì (1~12)
  const NATIVE_HOUR = {
    'ì—´ë‘': 12,
    'ì—´í•œ': 11,
    'ì—´': 10,
    'ì•„í™‰': 9,
    'ì—¬ëŸ': 8,
    'ì¼ê³±': 7,
    'ì—¬ì„¯': 6,
    'ë‹¤ì„¯': 5,
    'ë„¤': 4,
    'ì„¸': 3,
    'ë‘': 2,
    'í•œ': 1
  };

  // ë‚ ì§œì—ì„œ ì“°ëŠ” ê³ ìœ ì–´ ìˆ«ì (í•˜ë£¨, ì´í‹€, ì‚¬í˜...)
  const NATIVE_DAY = {
    'í•˜ë£¨': 1,
    'ì´í‹€': 2,
    'ì‚¬í˜': 3,
    'ë‚˜í˜': 4,
    'ë‹·ìƒˆ': 5,
    'ì—¿ìƒˆ': 6,
    'ì´ë ˆ': 7,
    'ì—¬ë“œë ˆ': 8,
    'ì•„íë ˆ': 9,
    'ì—´í˜': 10
  };

  // ì‹œê°„ëŒ€ ê¸°ë³¸ê°’ (ì‹œ/ë¶„ì´ ì „í˜€ ì—†ì„ ë•Œ)
  const PERIOD_DEFAULT_HOUR = {
    'ìƒˆë²½': 2,
    'ì•„ì¹¨': 8,
    'ì˜¤ì „': 9,
    'ì ì‹¬': 12,
    'ì •ì˜¤': 12,
    'ì €ë…': 19,
    'ë°¤': 21,
    'ì˜¤í›„': 15,
    'ìì •': 0
  };

  // "ì‚¼ì‹­ì˜¤" -> 35, "ì´ì‹­" -> 20, "ì˜¤" -> 5
  function parseSinoNumber(str) {
    str = str.trim();
    if (!str) return NaN;

    const idx = str.indexOf('ì‹­');
    if (idx !== -1) {
      const left = str.slice(0, idx);      // "ì‚¼ì‹­ì˜¤"ì—ì„œ "ì‚¼"
      const right = str.slice(idx + 1);    // "ì‚¼ì‹­ì˜¤"ì—ì„œ "ì˜¤"
      let tens = 1; // "ì‹­" ë‹¨ë…ì´ë©´ 10

      if (left.length > 0) {
        if (left.length !== 1 || !(left in KOREAN_DIGITS)) return NaN;
        tens = KOREAN_DIGITS[left];
      }

      let num = tens * 10;

      if (right.length > 0) {
        if (right.length !== 1 || !(right in KOREAN_DIGITS)) return NaN;
        num += KOREAN_DIGITS[right];
      }
      return num;
    }

    // ì‹­ì´ ì—†ëŠ” ê²½ìš°: í•œ ê¸€ì ìˆ«ìë§Œ í—ˆìš©
    if (str.length === 1 && str in KOREAN_DIGITS) {
      return KOREAN_DIGITS[str];
    }

    return NaN;
  }

  /**
   * ê³µí†µ ìˆ«ì íŒŒì„œ
   * type: 'hour' | 'minute' | 'day'
   */
  function parseKoreanNumber(str, type) {
    if (!str) return NaN;

    // (1) ë‚ ì§œ ë‹¨ì–´ ë¨¼ì € ì œê±°
    str = str.replace(/ì˜¤ëŠ˜|ë‚´ì¼|ëª¨ë ˆ|ê¸€í”¼|ì–´ì œ|ê·¸ì œ/g, '');

    // (2) ì‹œê°„ ê´€ë ¨ ë‹¨ìœ„ ì œê±° (âš  'ì¼'ì€ ì œê±°í•˜ì§€ ì•ŠëŠ”ë‹¤!)
    str = str.replace(/ì˜¤ì „|ì˜¤í›„|ì•„ì¹¨|ì €ë…|ë°¤|ìƒˆë²½|ë’¤|í›„|ì‹œ|ë¶„|ì‹œê°„/g, '');

    if (!str) return NaN;

    // 1) ì•„ë¼ë¹„ì•„ ìˆ«ì ìš°ì„ 
    const numMatch = str.match(/\d+/);
    if (numMatch) {
      return parseInt(numMatch[0], 10);
    }

    // 2) ê³ ìœ ì–´ ì²˜ë¦¬
    if (type === 'hour') {
      const nativeKeys = Object.keys(NATIVE_HOUR)
        .sort((a, b) => b.length - a.length);
      for (const k of nativeKeys) {
        if (str.startsWith(k)) {
          return NATIVE_HOUR[k];
        }
      }
    } else if (type === 'day') {
      const nativeKeys = Object.keys(NATIVE_DAY)
        .sort((a, b) => b.length - a.length);
      for (const k of nativeKeys) {
        if (str.startsWith(k)) {
          return NATIVE_DAY[k];
        }
      }
    }

    // 3) í•œìì–´(ì¼, ì´, ì‚¼, ì‚¬â€¦) ì²˜ë¦¬
    return parseSinoNumber(str);
  }

  // ======= ì¼(day) ê¸°ì¤€ ìƒëŒ€ í‘œí˜„ ì²˜ë¦¬ =======
  // ì˜ˆ: "3ì¼í›„", "ì‚¼ì¼ë’¤", "ì´í‹€ë’¤", "ì‚¬í˜í›„"
  // 3.1 Nì¼ ë’¤/í›„
  const dayMatch = text.match(/([0-9ê°€-í£]+)ì¼(ë’¤|í›„)/);
  if (dayMatch) {
    const dayStr = dayMatch[1];
    const d = parseKoreanNumber(dayStr, 'day');
    if (!isNaN(d)) {
      dayOffset += d;
      isRelative = true;
    }
  }

  // 3.2 "í•˜ë£¨ë’¤", "ì´í‹€í›„" ê°™ì€ í‘œí˜„
  for (const [key, val] of Object.entries(NATIVE_DAY)) {
    if (text.includes(key + 'ë’¤') || text.includes(key + 'í›„')) {
      dayOffset += val;
      isRelative = true;
      break;
    }
  }

  // ================== ìƒëŒ€ ì‹œê°„(íƒ€ì´ë¨¸) ==================
  if (isRelative) {
    // ì‹œê°„ ë‹¨ìœ„ê°€ ìˆëŠ”ì§€ í™•ì¸
    if (text.includes('ì‹œê°„')) {
      // "í•œì‹œê°„ë°˜ë’¤", "ë‘ì‹œê°„ì‚¼ì‹­ë¶„í›„" ë“± ì²˜ë¦¬
      const hourPart = text.split('ì‹œê°„')[0]; // "í•œ", "ë‘", "1", "ì„¸" ë“±
      const parsedHour = parseKoreanNumber(hourPart, 'hour');
      if (!isNaN(parsedHour)) hour = parsedHour;

      const afterHour = text.split('ì‹œê°„')[1];

      // ì‹œê°„ ë’¤ì— "ë°˜" ìˆìœ¼ë©´ +30ë¶„
      if (afterHour.includes('ë°˜')) {
        minute = 30;
      }

      // "Në¶„" í‘œì‹œê°€ ìˆìœ¼ë©´ ë®ì–´ì“°ê¸°
      if (afterHour.includes('ë¶„')) {
        const minPart = afterHour.split('ë¶„')[0];
        const parsedMin = parseKoreanNumber(minPart, 'minute');
        if (!isNaN(parsedMin)) minute = parsedMin;
      }
    } else {
      // "ì‹œê°„" ì—†ì´ "Në¶„ë’¤", "ì´ì‹­ë¶„í›„" ë“±
      if (text.includes('ë°˜')) {
        minute = 30;
      } else if (text.includes('ë¶„')) {
        const minPart = text.split('ë¶„')[0];
        const parsedMin = parseKoreanNumber(minPart, 'minute');
        if (!isNaN(parsedMin)) minute = parsedMin;
      } else {
        // ë‹¨ìœ„ ì—†ìœ¼ë©´ ë¶„ìœ¼ë¡œ ê°€ì •: "10ë’¤", "ì´ì‹­ë’¤"
        const parsedMin = parseKoreanNumber(text, 'minute');
        if (!isNaN(parsedMin)) minute = parsedMin;
      }
    }

  // ================== ì ˆëŒ€ ì‹œê°„(ì‹œê³„) ==================
  } else {
    if (text.includes('ì‹œ')) {
      const hourPart = text.split('ì‹œ')[0];
      const parsedHour = parseKoreanNumber(hourPart, 'hour');
      if (!isNaN(parsedHour)) hour = parsedHour;

      const afterHour = text.split('ì‹œ')[1];

      if (afterHour.includes('ë°˜')) {
        minute = 30;
      } else if (afterHour.includes('ë¶„')) {
        const minPart = afterHour.split('ë¶„')[0];
        const parsedMin = parseKoreanNumber(minPart, 'minute');
        if (!isNaN(parsedMin)) minute = parsedMin;
      }
    } else if (text.includes('ë¶„') || text.includes('ë°˜')) {
      // "10ë¶„", "ì´ì‹­ë¶„", "ë°˜"ë§Œ ìˆëŠ” ê²½ìš° (ì‹œ = 0ì‹œ)
      if (text.includes('ë°˜')) {
        minute = 30;
      } else {
        const minPart = text.split('ë¶„')[0];
        const parsedMin = parseKoreanNumber(minPart, 'minute');
        if (!isNaN(parsedMin)) minute = parsedMin;
      }
    } else {
      // ê·¸ëƒ¥ "5", "ì—´ë‘", "ì—¬ëŸ" ë“±ë§Œ ë‚˜ì˜¨ ê²½ìš°: ì‹œë¡œ ê°€ì •
      const parsedHour = parseKoreanNumber(text, 'hour');
      if (!isNaN(parsedHour)) hour = parsedHour;
    }

    // ì˜¤ì „/ì˜¤í›„ ë³´ì •
    if (isPM && hour < 12 && hour > 0) {
      hour += 12;          // ì˜¤í›„ 3ì‹œ -> 15ì‹œ
    } else if (isAM && hour === 12) {
      hour = 0;            // ì˜¤ì „ 12ì‹œ -> 0ì‹œ
    }

    // ì‹œ/ë¶„ì´ ì „í˜€ ì—†ê³ , ì‹œê°„ëŒ€ ë‹¨ì–´ë§Œ ìˆëŠ” ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
    if (hour === 0 && minute === 0) {
      for (const [key, val] of Object.entries(PERIOD_DEFAULT_HOUR)) {
        if (text.includes(key)) {
          hour = val;
          break;
        }
      }
    }
  }

  return { hour, minute, isRelative, dayOffset };
}


// --- [ìˆ˜ì •] ì•ŒëŒ ìš¸ë¦¼ ì‹œë®¬ë ˆì´ì…˜ ---
    function ringAlarm() {
        console.log("ğŸ”” ë ë¦¬ë§! ì•ŒëŒì´ ìš¸ë¦½ë‹ˆë‹¤!");

        // 1. [ìˆ˜ì •] ë¡œë´‡ ìœ„ì¹˜ì—ì„œ 'Alarm.mp3'ì™€ í•¨ê»˜ ë§ ë°œìƒ
        triggerAlarm();

        // 2. UI ê¹œë¹¡ì„ íš¨ê³¼ (ê¸°ì¡´ ë™ì¼)
        const container = document.getElementById("alarm-container");
        if (container) {
            container.style.backgroundColor = "rgba(255, 0, 0, 0.5)";
            container.style.transform = "scale(1.1)";
            container.style.transition = "all 0.2s";

            setTimeout(() => {
                container.style.backgroundColor = "";
                container.style.transform = "scale(1.0)";
            }, 500);
        }
    }
    // --- [ìˆ˜ì •] ì•ŒëŒ UI ë° ë°ì´í„° ê´€ë¦¬ í•¨ìˆ˜ ---
    function addAlarmToUI(targetTime) {
        const container = document.getElementById("alarm-container");
        
        const timeString = targetTime.toLocaleTimeString('ko-KR', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });

        const item = document.createElement("div");
        item.className = "alarm-item";
        item.innerHTML = `
            <span class="alarm-time">â° ${timeString}</span>
            <span class="delete-hint">âœ–</span>
        `;

        const alarmData = { 
            time: targetTime, 
            element: item     
        };
        alarmList.push(alarmData);
        console.log(`ğŸ’¾ ë°ì´í„° ì €ì¥ë¨. í˜„ì¬ ì•ŒëŒ ê°œìˆ˜: ${alarmList.length}ê°œ`);

        // [ìˆ˜ì •ëœ í´ë¦­ ì´ë²¤íŠ¸]
        item.addEventListener("click", function() {
            
            // 1. [ì¶”ê°€ë¨] ì‚­ì œí•˜ê¸° ì „ì— ì•ŒëŒ íš¨ê³¼(ì§„ë™+UIê¹œë¹¡ì„) ì‹¤í–‰!
            ringAlarm(); 

            // 2. ì‚­ì œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë¶‰ê²Œ ë³€í•˜ë©° ì‚¬ë¼ì§)
            item.classList.add("removing");
            
            // 3. 0.3ì´ˆ ë’¤ì— ë°ì´í„° ë° UI ì™„ì „íˆ ì œê±°
            setTimeout(() => {
                item.remove(); 
                
                const index = alarmList.indexOf(alarmData);
                if (index > -1) {
                    alarmList.splice(index, 1);
                    console.log(`ğŸ—‘ï¸ ì•ŒëŒ í™•ì¸ ë° ì‚­ì œë¨: ${timeString}`);
                }
            }, 300);
        });

        container.appendChild(item); 
    }
    // ------------------------------------------
    // --- [ìƒˆ ê¸°ëŠ¥] ì½˜ì†” ëª…ë ¹ì–´ íŒŒì„œ í•¨ìˆ˜ ---
    /**
     * (F12 ì½˜ì†” í…ŒìŠ¤íŠ¸ìš©)
     * ì™¸ë¶€ ê¸°ê¸°ì—ì„œ ë°›ì€ ê²ƒê³¼ ìœ ì‚¬í•œ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_1>(direction=1)<maum_end>"
     */
    // --- [ìˆ˜ì •] ì •ê·œì‹ì„ ì§€ì›í•˜ë„ë¡ if/else ifë¡œ ë³€ê²½ëœ íŒŒì„œ í•¨ìˆ˜ ---
    /**
     * ì™¸ë¶€ ê¸°ê¸°ì—ì„œ ë°›ì€ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_1>..." ë˜ëŠ” "<maum_2>..."
     */
    /**
     * ì™¸ë¶€ ê¸°ê¸°/ì•ˆë“œë¡œì´ë“œì—ì„œ ë°›ì€ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_0>(direction=1)<maum_end>"
     */
function parseCommand(message) {
  console.log(`ìˆ˜ì‹ ëœ ì›ë³¸ ë©”ì‹œì§€: ${message}`);

  // 1) ë°©í–¥ ì´ë™: <maum_0>(direction=1..4)[<maum_end> ìƒëµ ê°€ëŠ¥]
  let m = message.match(/^<maum_0>\(direction=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const dir = Number(m[1]);
    moveRobotInDirection(dir);
    return;
  }

  // 2) ëª©ì ì§€ ì´ë™: <maum_1>(direction=1..3)[<maum_end> ìƒëµ ê°€ëŠ¥]
  m = message.match(/^<maum_1>\(direction=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const dir = Number(m[1]);
    if (dir === 1) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'living_room'ìœ¼ë¡œ ì´ë™");
      moveToRoom("living_room");
    } else if (dir === 2) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'inner_room'ìœ¼ë¡œ ì´ë™");
      moveToRoom("inner_room");
    } else if (dir === 3) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'kitchen'ìœ¼ë¡œ ì´ë™");
      moveToRoom("kitchen");
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” ëª©ì ì§€ direction:", dir);
    }
    return;
  }

  // 3) ì‹œê°„ ì•Œë¦¼: <maum_2>(mode=2, time="...")[<maum_end> ì˜µì…˜]
  const timeMatch = message.match(/<maum_2>\(mode=2,\s*time="([^"]+)"\)(?:<maum_end>)?$/);

  if (timeMatch) {
      const rawTime = timeMatch[1]; // ì˜ˆ: "ì¼ê³±ì‹œì´ì‹­ì˜¤ë¶„"
      // [ìˆ˜ì •] í•œê¸€ íŒŒì„œ í˜¸ì¶œ!
      const timeData = convertKoreanToTime(rawTime);
      
     if (timeMatch) {
      const rawTime = timeMatch[1]; 
      const timeData = convertKoreanToTime(rawTime);
      
      // 1. ê¸°ì¤€ì´ ë  í˜„ì¬ ì‹œê°„ ê°ì²´ ìƒì„±
      const targetTime = new Date();

      if (timeData.isRelative) {
        // --- A. ìƒëŒ€ ì‹œê°„ (íƒ€ì´ë¨¸) ---
        // í˜„ì¬ ì‹œê°„ + ì…ë ¥ëœ ì‹œê°„
        targetTime.setHours(targetTime.getHours() + timeData.hour);
        targetTime.setMinutes(targetTime.getMinutes() + timeData.minute);
        
        console.log(`â° [íƒ€ì´ë¨¸] "${rawTime}" ê°ì§€ (+${timeData.hour}ì‹œê°„ ${timeData.minute}ë¶„)`);

      } else {
        // --- B. ì ˆëŒ€ ì‹œê°„ (ì•ŒëŒ) ---
        // ì‹œê°„ì„ ì…ë ¥ëœ ê°’ìœ¼ë¡œ "ê³ ì •"
        targetTime.setHours(timeData.hour);
        targetTime.setMinutes(timeData.minute);
        targetTime.setSeconds(0); // ì´ˆëŠ” 00ì´ˆë¡œ ê¹”ë”í•˜ê²Œ

        // (ì„ íƒ ì‚¬í•­) ë§Œì•½ ì„¤ì •í•œ ì‹œê°„ì´ í˜„ì¬ë³´ë‹¤ ê³¼ê±°ë¼ë©´(ì˜ˆ: ì˜¤í›„ 3ì‹œì— 'ì˜¤ì „ 9ì‹œ' ì„¤ì •), 
        // 'ë‚´ì¼'ë¡œ ì¡ì•„ì•¼ í•˜ì§€ë§Œ, ì¼ë‹¨ì€ ì˜¤ëŠ˜ ë‚ ì§œ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
        
        console.log(`â° [ì•ŒëŒ] "${rawTime}" ê°ì§€ -> ${timeData.hour}ì‹œ ${timeData.minute}ë¶„ìœ¼ë¡œ ì„¤ì •`);
      }

   // -------------------------------------------------------
      // [ìˆ˜ì •] ì´ì œ í•¨ìˆ˜ í˜¸ì¶œ í•œ ë²ˆìœ¼ë¡œ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤!
      addAlarmToUI(targetTime);
      // -------------------------------------------------------
      
      console.log(`   => ëª©í‘œ ì‹œê°: ${targetTime.toLocaleTimeString()}`);
    }
    return;
  }
 // 4) ì†ë„ ì¡°ì ˆ: <maum_3>(mode=1|2)[<maum_end> ì˜µì…˜]
  m = message.match(/^<maum_3>\(mode=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const mode = Number(m[1]);
    
    if (mode === 1) {
      console.log("ì†ë„ ì—…");
      MoveSpeed *= 2; // 1. ê¸°ì¤€ ì†ë„ ì¦ê°€

      // [ìˆ˜ì • 2] ì†ë„(Lerp)ëŠ” ìµœëŒ€ 0.99ê¹Œì§€ë§Œ ì»¤ì§€ë„ë¡ ì œí•œí•©ë‹ˆë‹¤. (1.0 ë„˜ìœ¼ë©´ ì—ëŸ¬!)
      commandMoveSpeed = Math.min(MoveSpeed * 0.1, 0.99); 
      
      console.log(`í˜„ì¬ ë³´í­: ${commandMoveStep.toFixed(3)}, ì†ë„: ${commandMoveSpeed.toFixed(3)}`);

    } else if (mode === 2) {
      console.log("ì†ë„ ë‹¤ìš´");
      MoveSpeed *= 0.5;
      // ì†ë„ ì¬ê³„ì‚°
      commandMoveSpeed = Math.min(MoveSpeed * 0.1, 0.9);
      
      console.log(`í˜„ì¬ ë³´í­: ${commandMoveStep.toFixed(3)}, ì†ë„: ${commandMoveSpeed.toFixed(3)}`);
      
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì†ë„ ëª¨ë“œ:", mode);
    }
    return;
  }

  // 5) í•¸ë“œí° ì°¾ê¸°: <maum_4>(mode=1|2)[<maum_end> ì˜µì…˜]
  m = message.match(/^<maum_4>\(mode=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const mode = Number(m[1]);
    if (mode === 1) {
      console.log("í•¸ë“œí° ì°¾ê¸°: ì†Œë¦¬ë¡œ ì°¾ê¸°");
      triggerRandomEffect();
    } else if (mode === 2) {
      console.log("í•¸ë“œí° ì°¾ê¸°: ì§„ë™ìœ¼ë¡œ ì°¾ê¸° (ì§€ê¸ˆì€ ë¡œê·¸ë§Œ)");
      triggerVibrationEffect();
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” í•¸ë“œí° ì°¾ê¸° ëª¨ë“œ:", mode);
    }
    return;
  }
  console.error(`ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì…ë‹ˆë‹¤: ${message}`);
}

    // ì½˜ì†”ì—ì„œ 'parseCommand' í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ì „ì—­ì— ë…¸ì¶œ
    window.parseCommand = parseCommand;
    // ì½˜ì†” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì „ì—­(window)ì— ë…¸ì¶œ
    //window.moveToRoom = moveToRoom;


    // --- 9. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

     // --- [ìˆ˜ì •] ì´í™íŠ¸ ì• ë‹ˆë©”ì´ì…˜ (íƒ€ì…ë³„ ë¶„ê¸°) ---
for (let i = activeEffects.length - 1; i >= 0; i--) {
          const effect = activeEffects[i];
          
          // ê³µí†µ: íˆ¬ëª…ë„ ê°ì†Œ
          effect.life -= 0.02;
          effect.mesh.material.opacity = Math.min(1.0, effect.life); // 1.0ì„ ë„˜ì§€ ì•Šê²Œ

          // --- [íƒ€ì…ë³„ ì• ë‹ˆë©”ì´ì…˜ ë¶„ê¸°] ---
          if (effect.type === 'explosion') {
              effect.mesh.scale.multiplyScalar(1.02); 

          } else if (effect.type === 'vibration') {
              effect.mesh.scale.multiplyScalar(1.03); 

          } else if (effect.type === 'alarm') { 
              effect.mesh.scale.multiplyScalar(1.015); 
          }
          // -----------------------------

          // ì‚­ì œ ë¡œì§ (ìˆ˜ëª… ë)
          if (effect.life <= 0) {
              scene.remove(effect.mesh);
              if(effect.mesh.geometry) effect.mesh.geometry.dispose();
              if(effect.mesh.material) effect.mesh.material.dispose();
              activeEffects.splice(i, 1);
          }
      }
      // ---------------------------------------

      // === [ì¹´ë©”ë¼ í•˜ì´ë¼ì´íŠ¸(í€ì¹˜ ì¤Œ) ì²˜ë¦¬] ===
      if (isHighlighting && model_car) {
        let t = (elapsed - highlightStartTime) / highlightTotalDuration;

        if (t >= 1) {
          // í•˜ì´ë¼ì´íŠ¸ ë
          isHighlighting = false;
          camera.position.copy(camFrom); // ì›ë˜ ìë¦¬ë¡œ ë³µê·€
          camera.lookAt(0, 0, 0);        // ê¸°ì¡´ì²˜ëŸ¼ ë°© ì „ì²´ ë°”ë¼ë³´ê¸°
        } else {
          // 0~0.5 : camFrom â†’ camTo, 0.5~1 : camTo â†’ camFrom
          let phase, from, to;
          if (t < 0.5) {
            phase = t / 0.5;
            from  = camFrom;
            to    = camTo;
          } else {
            phase = (t - 0.5) / 0.5;
            from  = camTo;
            to    = camFrom;
          }

          // ë¶€ë“œëŸ¬ìš´ ì´ì§• (smoothstep)
          const e = phase * phase * (3 - 2 * phase);

          camera.position.lerpVectors(from, to, e);
          camera.lookAt(model_car.position); // ì¤Œí•˜ëŠ” ë™ì•ˆì€ RCì¹´ë¥¼ ë°”ë¼ë´„
        }
      } else {
        // í•˜ì´ë¼ì´íŠ¸ ì•„ë‹ ë•ŒëŠ” ê¸°ì¡´ì²˜ëŸ¼ ì›ì (ì§‘ ì „ì²´) ë°”ë¼ë³´ê¸°
        camera.lookAt(0, 0, 0);
      }

      if (model_car) {
        // A. ìë™ ì´ë™ ëª¨ë“œ (currentTargetì´ ì„¤ì •ëœ ê²½ìš°)
        if (currentTarget) {
          model_car.position.lerp(currentTarget, 0.05); 
          model_car.lookAt(currentTarget); 

          // ëª©í‘œ ë„ë‹¬ ì‹œ
          if (model_car.position.distanceTo(currentTarget) < 0.01) {
            model_car.position.copy(currentTarget); // ìœ„ì¹˜ ìŠ¤ëƒ…

            if (movementQueue.length > 0) {
              currentTarget = movementQueue.shift(); 
            } else {
              // [ì—¬ê¸°ê°€ ì´ë™ ì™„ë£Œ ì‹œì ì…ë‹ˆë‹¤]
              currentTarget = null; 

              // âœ… [í•µì‹¬ ìˆ˜ì •] ìë™ ì´ë™ì´ ëë‚¬ìœ¼ë©´, ìˆ˜ë™ ëª©í‘œ ì§€ì ë„ í˜„ì¬ ìœ„ì¹˜ë¡œ ì—…ë°ì´íŠ¸!
              // ì´ê±¸ ì•ˆ í•˜ë©´ ì°¨ê°€ ë‹¤ì‹œ ì˜›ë‚  ìœ„ì¹˜ë¡œ ëŒì•„ê°€ ë²„ë¦½ë‹ˆë‹¤.
              if (targetPosition) {
                  targetPosition.copy(model_car.position);
                  targetRotation = model_car.rotation.y;
              }
            }
          }
        }
        // B. ìˆ˜ë™ ì¡°ì‘ ëª¨ë“œ (currentTargetì´ nullì¸ ê²½ìš°)
        else if (targetPosition) {
          
          // 1. ìœ„ì¹˜ ë¶€ë“œëŸ½ê²Œ ì´ë™ (commandMoveSpeedëŠ” ì†ë„, ë†’ì„ìˆ˜ë¡ ë¹ ë¦„)
          model_car.position.lerp(targetPosition, commandMoveSpeed);

          // 2. íšŒì „ ë¶€ë“œëŸ½ê²Œ ì´ë™
          // (ë‹¨ìˆœ lerp êµ¬í˜„: í˜„ì¬ ê°’ê³¼ ëª©í‘œ ê°’ì˜ ì°¨ì´ë¥¼ ì¡°ê¸ˆì”© ì¤„ì„)
          model_car.rotation.y += (targetRotation - model_car.rotation.y) * 0.1;

        }
      }

      renderer.render(scene, camera); // ì”¬ ë Œë”ë§

      labelRenderer.render(scene, camera);
    }
    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ 1íšŒë§Œ í˜¸ì¶œ
    animate();


    // --- 10. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

    // ë¸Œë¼ìš°ì € ì°½ í¬ê¸° ë³€ê²½
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      // [ì¶”ê°€] ë¼ë²¨ ë Œë”ëŸ¬ë„ í¬ê¸° ì—…ë°ì´íŠ¸
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });

    // í‚¤ë³´ë“œ ëˆ„ë¦„
    window.addEventListener('keydown', (e) => {
      if (e.key in keys) {
        keys[e.key] = true;
      }
    });

    // í‚¤ë³´ë“œ ë—Œ
    window.addEventListener('keyup', (e) => {
      if (e.key in keys) {
        keys[e.key] = false;
      }
    });

    // ë§ˆìš°ìŠ¤ íœ  ì¤Œ
    window.addEventListener('wheel', (e) => {
      const direction = camera.position.clone().normalize();
      let distance = camera.position.length();
      
      distance += e.deltaY * zoomSpeed; // ìŠ¤í¬ë¡¤ ë°©í–¥ì— ë”°ë¼ ê±°ë¦¬ ì¡°ì ˆ
      distance = Math.max(minZoomDistance, Math.min(maxZoomDistance, distance)); // ê±°ë¦¬ ì œí•œ
      
      camera.position.copy(direction).multiplyScalar(distance); // ìƒˆ ìœ„ì¹˜ ì ìš©
    });
    
    // 1ì´ˆë§ˆë‹¤ ìë™ì°¨ ì¢Œí‘œ ì½˜ì†”ì— ì¶œë ¥
    setInterval(() => {
      if (model_car) {
        const x = model_car.position.x.toFixed(2);
        const y = model_car.position.y.toFixed(2);
        const z = model_car.position.z.toFixed(2);
        console.log(`ğŸš— Car Position: (x: ${x}, y: ${y}, z: ${z})`);
      }
    }, 1000); // 1ì´ˆ

  </script>
</body>
</html>