<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Three.js ì…ë¬¸</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.141.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    const ws = new WebSocket("ws://192.168.0.3:3001"); // ë§¥ IPë¡œ ë„£ê¸°
    ws.onopen = () => {
      console.log("WebSocket Connected to server");
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "command") {
          console.log("ì„œë²„ì—ì„œ ëª…ë ¹ ìˆ˜ì‹ :", data.command);
          parseCommand(data.command);    // ì½˜ì†” ëª…ë ¹ì–´ íŒŒì„œ í•¨ìˆ˜ í˜¸ì¶œ
        }
      } catch (e) {
        console.error("ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜", e);
      }
    };
    // --- ëª¨ë“ˆ ì„í¬íŠ¸ ---
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- ì „ì—­ ë³€ìˆ˜ ---
    let model_car;
    const clock = new THREE.Clock();

    // í‚¤ë³´ë“œ ìƒíƒœ
    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
    };
    
    // ë§ˆìš°ìŠ¤ íœ  ì¤Œ ì„¤ì •
    const minZoomDistance = 2.0;
    const maxZoomDistance = 15.0;
    const zoomSpeed = 0.005;
    
    // --- ë°© ì¢Œí‘œ ë° ìë™ ì´ë™ ë³€ìˆ˜ ---

    const car_y = 0.2;
    const roomData = {
      living_room: new THREE.Vector3(0.0, car_y, -0.3),
      inner_room: new THREE.Vector3(0.25, car_y, 1.2),
      kitchen: new THREE.Vector3(-0.9, car_y, 0.0)
    };

    // ì¤‘ê°„ ê²½ë¡œì  (Waypoint) ì •ì˜
    const INNER_ROOM_DOORWAY = new THREE.Vector3(
      0.2,
      car_y,
      0.4
    );
    const KITCHEN_DOORWAY = new THREE.Vector3(
      -0.75,
      car_y,
      -0.15
    );

    // ì´ë™ ê²½ë¡œ(Path) ë°ì´í„°
    const pathData = {
      living_room_to_inner_room: [ INNER_ROOM_DOORWAY, roomData.inner_room ],
      inner_room_to_living_room: [ INNER_ROOM_DOORWAY, roomData.living_room ],
      living_room_to_kitchen: [ KITCHEN_DOORWAY, roomData.kitchen ],
      kitchen_to_living_room: [ KITCHEN_DOORWAY, roomData.living_room ],
      inner_room_to_kitchen: [ INNER_ROOM_DOORWAY, roomData.living_room, KITCHEN_DOORWAY, roomData.kitchen ],
      kitchen_to_inner_room: [ KITCHEN_DOORWAY, roomData.living_room, INNER_ROOM_DOORWAY, roomData.inner_room ]
    };

    // ìë™ ì´ë™ ìƒíƒœ ë³€ìˆ˜
    let currentRoom = "living_room"; // ìë™ì°¨ì˜ í˜„ì¬ ë°© (ì‹œì‘ ìœ„ì¹˜)
    let movementQueue = []; // ë”°ë¼ê°ˆ ê²½ë¡œì  ë°°ì—´
    let currentTarget = null; // í˜„ì¬ ì´ë™ ì¤‘ì¸ ëª©í‘œ ê²½ë¡œì 
    
    // --- 3. Scene ìƒì„± ---
    let scene = new THREE.Scene();
    scene.background = new THREE.Color("skyblue");

    // --- 4. Camera ìƒì„± ---
    let camera = new THREE.PerspectiveCamera(
      45, // fov
      window.innerWidth / window.innerHeight, // aspect
      0.1, // near
      1000 // far
    );
    camera.position.set(0, 5, 2); // Yì¶•ì„ ë†’ì—¬ ìœ„ì—ì„œ ë³´ë„ë¡ ì„¤ì •
    // === [í•˜ì´ë¼ì´íŠ¸(í€ì¹˜ ì¤Œ)ìš© ì „ì—­ ë³€ìˆ˜ ì¶”ê°€] ===
    let isHighlighting = false;
    let highlightStartTime = 0;
    const highlightTotalDuration = 0.6; // ì „ì²´ ì¤Œ ì¸+ì•„ì›ƒ ì‹œê°„(ì´ˆ)

    const camFrom = new THREE.Vector3(); // ì›ë˜ ì¹´ë©”ë¼ ìœ„ì¹˜
    const camTo   = new THREE.Vector3(); // RCì¹´ ê°€ê¹Œì´ì—ì„œ ë³¼ ì¹´ë©”ë¼ ìœ„ì¹˜
    const highlightOffset = new THREE.Vector3(0.4, 0.6, 0.8); // ì°¨ ê¸°ì¤€ìœ¼ë¡œ ì‚´ì§ ìœ„/ì• ëŒ€ê°ì„ ì—ì„œ ë³´ëŠ” ìœ„ì¹˜ ì˜¤í”„ì…‹

    // --- 5. Light ì¶”ê°€ ---
    let PLight = new THREE.PointLight(0xffffff, 1.0);
    let ALight = new THREE.AmbientLight(0xffffff, 0.5);
    PLight.position.set(10, 10, 10);
    scene.add(PLight, ALight);

    // --- 6. Renderer ìƒì„± ---
    let renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector("#canvas"),
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;

    // --- 7. 3D ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ---
    let loader = new GLTFLoader();
    
    const modelPath_House = "models/house_ex4.glb";
    const modelPath_Car = "models/car_pika.glb"; // (ê²½ë¡œ ë’¤ ê³µë°± ì œê±°ë¨)

    loader.load(modelPath_House, function (gltf) {
      const model = gltf.scene;
      model.scale.set(2, 2, 2);
      scene.add(model);
    });
    
    loader.load(modelPath_Car, function (gltf) {
      model_car = gltf.scene;
      model_car.scale.set(0.1, 0.1, 0.1);
      model_car.position.set(0.0,car_y,-0.3);
      scene.add(model_car);
    });

    // --- 8. ìë™ ì´ë™ í•¨ìˆ˜ ---
    /**
     * ì§€ì •ëœ ë°©ìœ¼ë¡œ ìë™ ì´ë™ì„ ì‹œì‘í•©ë‹ˆë‹¤.
     */
    function moveToRoom(toRoomName) {
      if (toRoomName === currentRoom || currentTarget) {
        return; // ì´ë¯¸ ì´ë™ ì¤‘ì´ê±°ë‚˜ ê°™ì€ ë°©ì´ë©´ ë¬´ì‹œ
      }
      
      const pathKey = `${currentRoom}_to_${toRoomName}`;
      const path = pathData[pathKey];

      if (!path) {
        console.error(`Error: '${pathKey}' ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }
      
      console.log(`ìë™ ì´ë™: ${pathKey}`);
      movementQueue = [...path]; // ê²½ë¡œ ë³µì‚¬

      if (movementQueue.length > 0) {
        // ìˆ˜ë™ ì¡°ì‘ í›„ ìœ„ì¹˜ ë³´ì •ì„ ìœ„í•´ ì‹œì‘ì (í˜„ì¬ ë°©)ìœ¼ë¡œ ì°¨ë¥¼ ìŠ¤ëƒ…
        model_car.position.copy(roomData[currentRoom]);
        currentTarget = movementQueue.shift(); // ì²« ë²ˆì§¸ ê²½ë¡œì  ì„¤ì •
      }
      
      currentRoom = toRoomName; // í˜„ì¬ ë°© ìƒíƒœ ê°±ì‹ 
      // ë°© ì´ë™ ëª…ë ¹ ë“¤ì–´ì˜¤ë©´ ì¹´ë©”ë¼ í•˜ì´ë¼ì´íŠ¸
      triggerHighlight();
    }
        // --- maum_0 ë°©í–¥ ëª…ë ¹ìš© ìˆ˜ë™ ì´ë™ í•¨ìˆ˜ ---
    const commandMoveStep = 0.3;             // í•œ ë²ˆì— ì´ë™ ê±°ë¦¬
    const commandRotateStep = Math.PI / 12;  // í•œ ë²ˆì— íšŒì „ ê°ë„

    function moveRobotInDirection(direction) {
      if (!model_car) {
        console.error("model_carê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
      }

      // ìˆ˜ë™ ì œì–´ ë“¤ì–´ì˜¤ë©´ ìë™ ê²½ë¡œëŠ” ëŠì–´ë²„ë¦¼
      currentTarget = null;
      movementQueue = [];

      switch (direction) {
        case 1: // ì•ìœ¼ë¡œ
          model_car.translateZ(commandMoveStep / model_car.scale.x);
          console.log("ì•ìœ¼ë¡œ ì´ë™");
          break;
        case 2: // ë’¤ë¡œ
          model_car.translateZ(-commandMoveStep / model_car.scale.x);
          console.log("ë’¤ë¡œ ì´ë™");
          break;
        case 3: // ì™¼ìª½ íšŒì „
          model_car.rotation.y += commandRotateStep;
          console.log("ì™¼ìª½ íšŒì „");
          break;
        case 4: // ì˜¤ë¥¸ìª½ íšŒì „
          model_car.rotation.y -= commandRotateStep;
          console.log("ì˜¤ë¥¸ìª½ íšŒì „");
          break;
        default:
          console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” direction ê°’:", direction);
      }
      // ë°©í–¥ ëª…ë ¹ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ ì ê¹ ì¤Œ ë•¡ê¸°ê¸°
      triggerHighlight();
    }

    // === [í•˜ì´ë¼ì´íŠ¸ íŠ¸ë¦¬ê±° í•¨ìˆ˜ ì¶”ê°€] ===
    function triggerHighlight() {
      if (!model_car) return;

      isHighlighting = true;
      highlightStartTime = clock.getElapsedTime();

      // í˜„ì¬ ì¹´ë©”ë¼ ìœ„ì¹˜ ì €ì¥
      camFrom.copy(camera.position);

      // RCì¹´ ê¸°ì¤€ìœ¼ë¡œ ì‚´ì§ ìœ„/ì•ì—ì„œ ë³´ëŠ” ìœ„ì¹˜ ê³„ì‚°
      camTo.copy(model_car.position).add(highlightOffset);
    }
    // --- [ìƒˆ ê¸°ëŠ¥] ì½˜ì†” ëª…ë ¹ì–´ íŒŒì„œ í•¨ìˆ˜ ---
    /**
     * (F12 ì½˜ì†” í…ŒìŠ¤íŠ¸ìš©)
     * ì™¸ë¶€ ê¸°ê¸°ì—ì„œ ë°›ì€ ê²ƒê³¼ ìœ ì‚¬í•œ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_1>(direction=1)<maum_end>"
     */
    // --- [ìˆ˜ì •] ì •ê·œì‹ì„ ì§€ì›í•˜ë„ë¡ if/else ifë¡œ ë³€ê²½ëœ íŒŒì„œ í•¨ìˆ˜ ---
    /**
     * ì™¸ë¶€ ê¸°ê¸°ì—ì„œ ë°›ì€ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_1>..." ë˜ëŠ” "<maum_2>..."
     */
    /**
     * ì™¸ë¶€ ê¸°ê¸°/ì•ˆë“œë¡œì´ë“œì—ì„œ ë°›ì€ í…ìŠ¤íŠ¸ ëª…ë ¹ì„ íŒŒì‹±í•©ë‹ˆë‹¤.
     * @param {string} message - ì˜ˆ: "<maum_0>(direction=1)<maum_end>"
     */
function parseCommand(message) {
  console.log(`ìˆ˜ì‹ ëœ ì›ë³¸ ë©”ì‹œì§€: ${message}`);

  // 1) ë°©í–¥ ì´ë™: <maum_0>(direction=1..4)[<maum_end> ìƒëµ ê°€ëŠ¥]
  let m = message.match(/^<maum_0>\(direction=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const dir = Number(m[1]);
    moveRobotInDirection(dir);
    return;
  }

  // 2) ëª©ì ì§€ ì´ë™: <maum_1>(direction=1..3)[<maum_end> ìƒëµ ê°€ëŠ¥]
  m = message.match(/^<maum_1>\(direction=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const dir = Number(m[1]);
    if (dir === 1) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'living_room'ìœ¼ë¡œ ì´ë™");
      moveToRoom("living_room");
    } else if (dir === 2) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'inner_room'ìœ¼ë¡œ ì´ë™");
      moveToRoom("inner_room");
    } else if (dir === 3) {
      console.log("ëª…ë ¹ íŒŒì‹±: 'kitchen'ìœ¼ë¡œ ì´ë™");
      moveToRoom("kitchen");
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” ëª©ì ì§€ direction:", dir);
    }
    return;
  }

  // 3) ì‹œê°„ ì•Œë¦¼: <maum_2>(mode=2, time="...")[<maum_end> ì˜µì…˜]
  m = message.match(/^<maum_2>\(mode=2,\s*time="(.+)"\)(?:<maum_end>)?$/);
  if (m) {
    const timeString = m[1];
    console.log(`ëª…ë ¹ íŒŒì‹±: ì•ŒëŒ ì„¤ì •, ì¶”ì¶œëœ ì‹œê°„ = ${timeString}`);
    return;
  }

  // 4) ì†ë„ ì¡°ì ˆ: <maum_3>(mode=1|2)[<maum_end> ì˜µì…˜]
  m = message.match(/^<maum_3>\(mode=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const mode = Number(m[1]);
    if (mode === 1) {
      console.log("ì†ë„ ì—… (ì§€ê¸ˆì€ ë¡œê·¸ë§Œ)");
    } else if (mode === 2) {
      console.log("ì†ë„ ë‹¤ìš´ (ì§€ê¸ˆì€ ë¡œê·¸ë§Œ)");
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì†ë„ ëª¨ë“œ:", mode);
    }
    return;
  }

  // 5) í•¸ë“œí° ì°¾ê¸°: <maum_4>(mode=1|2)[<maum_end> ì˜µì…˜]
  m = message.match(/^<maum_4>\(mode=(\d+)\)(?:<maum_end>)?$/);
  if (m) {
    const mode = Number(m[1]);
    if (mode === 1) {
      console.log("í•¸ë“œí° ì°¾ê¸°: ì†Œë¦¬ë¡œ ì°¾ê¸° (ì§€ê¸ˆì€ ë¡œê·¸ë§Œ)");
    } else if (mode === 2) {
      console.log("í•¸ë“œí° ì°¾ê¸°: ì§„ë™ìœ¼ë¡œ ì°¾ê¸° (ì§€ê¸ˆì€ ë¡œê·¸ë§Œ)");
    } else {
      console.error("ì§€ì›í•˜ì§€ ì•ŠëŠ” í•¸ë“œí° ì°¾ê¸° ëª¨ë“œ:", mode);
    }
    return;
  }

  console.error(`ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì…ë‹ˆë‹¤: ${message}`);
}

    // ì½˜ì†”ì—ì„œ 'parseCommand' í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ì „ì—­ì— ë…¸ì¶œ
    window.parseCommand = parseCommand;
    // ì½˜ì†” í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì „ì—­(window)ì— ë…¸ì¶œ
    //window.moveToRoom = moveToRoom;


    // --- 9. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // === [ì¹´ë©”ë¼ í•˜ì´ë¼ì´íŠ¸(í€ì¹˜ ì¤Œ) ì²˜ë¦¬] ===
      if (isHighlighting && model_car) {
        let t = (elapsed - highlightStartTime) / highlightTotalDuration;

        if (t >= 1) {
          // í•˜ì´ë¼ì´íŠ¸ ë
          isHighlighting = false;
          camera.position.copy(camFrom); // ì›ë˜ ìë¦¬ë¡œ ë³µê·€
          camera.lookAt(0, 0, 0);        // ê¸°ì¡´ì²˜ëŸ¼ ë°© ì „ì²´ ë°”ë¼ë³´ê¸°
        } else {
          // 0~0.5 : camFrom â†’ camTo, 0.5~1 : camTo â†’ camFrom
          let phase, from, to;
          if (t < 0.5) {
            phase = t / 0.5;
            from  = camFrom;
            to    = camTo;
          } else {
            phase = (t - 0.5) / 0.5;
            from  = camTo;
            to    = camFrom;
          }

          // ë¶€ë“œëŸ¬ìš´ ì´ì§• (smoothstep)
          const e = phase * phase * (3 - 2 * phase);

          camera.position.lerpVectors(from, to, e);
          camera.lookAt(model_car.position); // ì¤Œí•˜ëŠ” ë™ì•ˆì€ RCì¹´ë¥¼ ë°”ë¼ë´„
        }
      } else {
        // í•˜ì´ë¼ì´íŠ¸ ì•„ë‹ ë•ŒëŠ” ê¸°ì¡´ì²˜ëŸ¼ ì›ì (ì§‘ ì „ì²´) ë°”ë¼ë³´ê¸°
        camera.lookAt(0, 0, 0);
      }

      if (model_car) {
        // A. ìë™ ì´ë™ ëª¨ë“œ (currentTargetì´ ì„¤ì •ëœ ê²½ìš°)
        if (currentTarget) {
          model_car.position.lerp(currentTarget, 0.05); // ëª©í‘œë¡œ 5%ì”© ì´ë™
          model_car.lookAt(currentTarget); // ëª©í‘œ ì§€ì  ë°”ë¼ë³´ê¸°

          // ëª©í‘œì— 0.01 ì´ë‚´ë¡œ ê·¼ì ‘í•˜ë©´
          if (model_car.position.distanceTo(currentTarget) < 0.01) {
            model_car.position.copy(currentTarget); // ì •í™•í•œ ìœ„ì¹˜ë¡œ ìŠ¤ëƒ…

            if (movementQueue.length > 0) {
              currentTarget = movementQueue.shift(); // ë‹¤ìŒ ê²½ë¡œì  ì„¤ì •
            } else {
              currentTarget = null; // ì´ë™ ì™„ë£Œ (ìˆ˜ë™ ëª¨ë“œ ì „í™˜)
            }
          }
        } 
        // B. ìˆ˜ë™ ì¡°ì‘ ëª¨ë“œ (currentTargetì´ nullì¸ ê²½ìš°)
        else {
          const moveSpeed = 0.1 * delta;
          const rotateSpeed = 5 * delta;

          if (keys.ArrowUp) {
            model_car.translateZ((moveSpeed / model_car.scale.x));
          }
          if (keys.ArrowDown) {
            model_car.translateZ(-(moveSpeed / model_car.scale.x));
          }
          if (keys.ArrowLeft) {
            model_car.rotation.y += rotateSpeed;
          }
          if (keys.ArrowRight) {
            model_car.rotation.y -= rotateSpeed;
          }
        }
      }

      renderer.render(scene, camera); // ì”¬ ë Œë”ë§
    }
    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ 1íšŒë§Œ í˜¸ì¶œ
    animate();


    // --- 10. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

    // ë¸Œë¼ìš°ì € ì°½ í¬ê¸° ë³€ê²½
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // í‚¤ë³´ë“œ ëˆ„ë¦„
    window.addEventListener('keydown', (e) => {
      if (e.key in keys) {
        keys[e.key] = true;
      }
    });

    // í‚¤ë³´ë“œ ë—Œ
    window.addEventListener('keyup', (e) => {
      if (e.key in keys) {
        keys[e.key] = false;
      }
    });

    // ë§ˆìš°ìŠ¤ íœ  ì¤Œ
    window.addEventListener('wheel', (e) => {
      const direction = camera.position.clone().normalize();
      let distance = camera.position.length();
      
      distance += e.deltaY * zoomSpeed; // ìŠ¤í¬ë¡¤ ë°©í–¥ì— ë”°ë¼ ê±°ë¦¬ ì¡°ì ˆ
      distance = Math.max(minZoomDistance, Math.min(maxZoomDistance, distance)); // ê±°ë¦¬ ì œí•œ
      
      camera.position.copy(direction).multiplyScalar(distance); // ìƒˆ ìœ„ì¹˜ ì ìš©
    });
    
    // 1ì´ˆë§ˆë‹¤ ìë™ì°¨ ì¢Œí‘œ ì½˜ì†”ì— ì¶œë ¥
    setInterval(() => {
      if (model_car) {
        const x = model_car.position.x.toFixed(2);
        const y = model_car.position.y.toFixed(2);
        const z = model_car.position.z.toFixed(2);
        console.log(`ğŸš— Car Position: (x: ${x}, y: ${y}, z: ${z})`);
      }
    }, 1000); // 1ì´ˆ

  </script>
</body>
</html>